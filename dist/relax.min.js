class Prop{obj;prop;constructor(t,s){this.obj=t,this.prop=s}involves(t){return this.obj===t}get(){return this.obj[this.prop]}set(t){this.obj[this.prop]=t}}class NumericDelta{ref;amount;constructor(t,s){this.ref=t,this.amount=s}isSignificant(t){return Math.abs(this.amount)>t}apply(t){this.ref.set(this.ref.get()+this.amount*t)}}class ValueConstraint{v;targetValue;constructor(t,s){this.v=t,this.targetValue=s}involves(t){return this.v.involves(t)}computeDeltas(t){return[new NumericDelta(this.v,this.targetValue-this.v.get())]}}class EqualityConstraint{p1;p2;constructor(t,s){this.p1=t,this.p2=s}involves(t){return this.p1.involves(t)||this.p2.involves(t)}computeDeltas(t){const s=this.p1.get()-this.p2.get();return[new NumericDelta(this.p1,-s/2),new NumericDelta(this.p2,+s/2)]}}class SumConstraint{addend1;addend2;sum;constructor(t,s,i){this.addend1=t,this.addend2=s,this.sum=i}involves(t){return this.addend1.involves(t)||this.addend2.involves(t)||this.sum.involves(t)}computeDeltas(t){const s=this.sum.get()-(this.addend1.get()+this.addend2.get());return[new NumericDelta(this.addend1,+s/3),new NumericDelta(this.addend2,+s/3),new NumericDelta(this.sum,-s/3)]}}const mod={Prop:Prop,NumericDelta:NumericDelta,ValueConstraint:ValueConstraint,EqualityConstraint:EqualityConstraint,SumConstraint:SumConstraint};class PointDelta{p;delta;constructor(t,s){this.p=t,this.delta=s}isSignificant(t){return magnitude(this.delta)>t}apply(t){const s=scaledBy(this.delta,t);this.p.x+=s.x,this.p.y+=s.y}}function square(t){return t*t}function plus(t,s){return{x:t.x+s.x,y:t.y+s.y}}function minus(t,s){return{x:t.x-s.x,y:t.y-s.y}}function scaledBy(t,s){return{x:t.x*s,y:t.y*s}}function copy(t){return scaledBy(t,1)}function midpoint(t,s){return scaledBy(plus(t,s),.5)}function magnitude(t){return Math.sqrt(square(t.x)+square(t.y))}function normalized(t){return scaledBy(t,1/magnitude(t))}function rotatedBy(t,s){const i=Math.cos(s),n=Math.sin(s);return{x:i*t.x-n*t.y,y:n*t.x+i*t.y}}function rotatedAround(t,s,i){return plus(i,rotatedBy(minus(t,i),s))}class CoordinateConstraint{p;c;constructor(t,s){this.p=t,this.c=s}involves(t){return this.p===t||this.c===t}computeDeltas(t){return[new PointDelta(this.p,minus(this.c,this.p))]}}class CoincidenceConstraint{p1;p2;constructor(t,s){this.p1=t,this.p2=s}involves(t){return this.p1===t||this.p2===t}computeDeltas(t){const s=scaledBy(minus(this.p2,this.p1),.5);return[new PointDelta(this.p1,s),new PointDelta(this.p2,scaledBy(s,-1))]}}class EquivalenceConstraint{p1;p2;p3;p4;constructor(t,s,i,n){this.p1=t,this.p2=s,this.p3=i,this.p4=n}involves(t){return this.p1===t||this.p2===t||this.p3===t||this.p4===t}computeDeltas(t){const s=scaledBy(minus(plus(this.p2,this.p3),plus(this.p1,this.p4)),.25);return[new PointDelta(this.p1,s),new PointDelta(this.p2,scaledBy(s,-1)),new PointDelta(this.p3,scaledBy(s,-1)),new PointDelta(this.p4,s)]}}class EqualDistanceConstraint{p1;p2;p3;p4;constructor(t,s,i,n){this.p1=t,this.p2=s,this.p3=i,this.p4=n}involves(t){return this.p1===t||this.p2===t||this.p3===t||this.p4===t}computeDeltas(t){const s=(magnitude(minus(this.p1,this.p2))-magnitude(minus(this.p3,this.p4)))/4,i=scaledBy(normalized(minus(this.p2,this.p1)),s),n=scaledBy(normalized(minus(this.p4,this.p3)),s);return[new PointDelta(this.p1,i),new PointDelta(this.p2,scaledBy(i,-1)),new PointDelta(this.p3,scaledBy(n,-1)),new PointDelta(this.p4,n)]}}class LengthConstraint{p1;p2;l;constructor(t,s,i){this.p1=t,this.p2=s,this.l=i}involves(t){return this.p1===t||this.p2===t}computeDeltas(t){const s=(magnitude(minus(this.p1,this.p2))-this.l)/2,i=scaledBy(normalized(minus(this.p2,this.p1)),s);return[new PointDelta(this.p1,i),new PointDelta(this.p2,scaledBy(i,-1))]}}class OrientationConstraint{p1;p2;p3;p4;theta;constructor(t,s,i,n,e){this.p1=t,this.p2=s,this.p3=i,this.p4=n,this.theta=e}involves(t){return this.p1===t||this.p2===t||this.p3===t||this.p4===t}computeDeltas(t){const s=minus(this.p2,this.p1),i=Math.atan2(s.y,s.x),n=midpoint(this.p1,this.p2),e=minus(this.p4,this.p3),o=Math.atan2(e.y,e.x),a=midpoint(this.p3,this.p4),r=i-o,h=this.theta-r;return[new PointDelta(this.p1,minus(rotatedAround(this.p1,h,n),this.p1)),new PointDelta(this.p2,minus(rotatedAround(this.p2,h,n),this.p2)),new PointDelta(this.p3,minus(rotatedAround(this.p3,-h,a),this.p3)),new PointDelta(this.p4,minus(rotatedAround(this.p4,-h,a),this.p4))]}}class MotorConstraint{p1;p2;w;lastT=Date.now();constructor(t,s,i){this.p1=t,this.p2=s,this.w=i}involves(t){return this.p1===t||this.p2===t}computeDeltas(t){const s=(t-this.lastT)/1e3;this.lastT=t;const i=s*this.w*(2*Math.PI),n=midpoint(this.p1,this.p2);return[new PointDelta(this.p1,minus(rotatedAround(this.p1,i,n),this.p1)),new PointDelta(this.p2,minus(rotatedAround(this.p2,i,n),this.p2))]}}const mod1={PointDelta:PointDelta,square:square,plus:plus,minus:minus,scaledBy:scaledBy,copy:copy,midpoint:midpoint,magnitude:magnitude,normalized:normalized,rotatedBy:rotatedBy,rotatedAround:rotatedAround,CoordinateConstraint:CoordinateConstraint,CoincidenceConstraint:CoincidenceConstraint,EquivalenceConstraint:EquivalenceConstraint,EqualDistanceConstraint:EqualDistanceConstraint,LengthConstraint:LengthConstraint,OrientationConstraint:OrientationConstraint,MotorConstraint:MotorConstraint};class Relax1{rho=.25;epsilon=.01;constraints=[];add(t){return this.constraints.push(t),t}remove(t){this.constraints=this.constraints.filter((s=>s!==t&&!s.involves(t)))}clear(){this.constraints=[]}getConstraints(){return this.constraints}doOneIteration(t){const s=[];return this.constraints.forEach((i=>{const n=i.computeDeltas(t);n.some((t=>t.isSignificant(this.epsilon)))&&s.push(...n)})),s.forEach((t=>t.apply(this.rho))),s.length>0}iterateForUpToMillis(t){let s=0;const i=Date.now();for(;Date.now()-i<t&&this.doOneIteration(i);)s++;return s}}export{mod as arith};export{mod1 as geom};export{Relax1 as Relax};
